class Solution {
public:
    long long maxSumTrionic(vector<int>& nums) {
        int n = nums.size();

        const long long NINF = -(1LL << 60);

        long long a = NINF, b = NINF, c = NINF, result = NINF;
        for (int i = 1; i < n; ++i) {
            long long x0 = nums[i - 1], x1 = nums[i];

            long long na = NINF, nb = NINF, nc = NINF;
            if (x0 < x1) { // up
                // Try a: start new a or extend current inc a
                na = max(x0 + x1, (a == NINF ? NINF : a + x1));

                // Try c: extend current inc c OR switch from dec b to inc c
                nc = max(c == NINF ? NINF : c + x1, b == NINF ? NINF : b + x1);

            } else if (x0 > x1)// down
                // Try b: extend current dec b OR switch from inc a to dec b
                nb = max(b == NINF ? NINF : b + x1, a == NINF ? NINF : a + x1);
            
            // else: equal => reset all (stay NINF)

            result = max(result, nc);
            a = na; b = nb; c = nc;
        }

        return result;
    }
};
